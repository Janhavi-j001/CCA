1. Quick sort

#include <stdio.h>

// Function to partition the array and return the pivot index
int partition(int arr[], int low, int high) {
    int pivot = arr[low];
    int i = low + 1;
    int j = high;

    while (1) {
        while (i <= j && arr[i] <= pivot)
            i++;
        while (j >= i && arr[j] > pivot)
            j--;
        if (i <= j) {
            // Swap arr[i] and arr[j]
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        } else {
            // Swap pivot (arr[low]) and arr[j]
            int temp = arr[low];
            arr[low] = arr[j];
            arr[j] = temp;
            return j; // Return the pivot index
        }
    }
}

// Function to perform Quick Sort
void quick_sort(int arr[], int low, int high) {
    if (low < high) {
        // Partition the array and get the pivot index
        int pivotIndex = partition(arr, low, high);

        // Recursively sort the subarrays
        quick_sort(arr, low, pivotIndex - 1);
        quick_sort(arr, pivotIndex + 1, high);
    }
}

// Function to print an array
void print_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Driver program to test the functions
int main() {
    int arr[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    int size = sizeof(arr) / sizeof(arr[0]);

    printf("Original Array: ");
    print_array(arr, size);

    // Perform Quick Sort
    quick_sort(arr, 0, size - 1);

    printf("Sorted Array: ");
    print_array(arr, size);

    return 0;
}
..................................................................

2. Merge sort

#include <stdio.h>
#include <stdlib.h>

// Function to merge two sorted subarrays into a single sorted array
void merge(int arr[], int left, int middle, int right) {
    int i, j, k;
    int n1 = middle - left + 1;
    int n2 = right - middle;

    // Create temporary arrays
    int *left_arr = (int *)malloc(n1 * sizeof(int));
    int *right_arr = (int *)malloc(n2 * sizeof(int));

    // Copy data to temporary arrays left_arr[] and right_arr[]
    for (i = 0; i < n1; i++)
        left_arr[i] = arr[left + i];
    for (j = 0; j < n2; j++)
        right_arr[j] = arr[middle + 1 + j];

    // Merge the temporary arrays back into arr[left..right]
    i = 0;
    j = 0;
    k = left;
    while (i < n1 && j < n2) {
        if (left_arr[i] <= right_arr[j]) {
            arr[k] = left_arr[i];
            i++;
        } else {
            arr[k] = right_arr[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of left_arr[], if there are any
    while (i < n1) {
        arr[k] = left_arr[i];
        i++;
        k++;
    }

    // Copy the remaining elements of right_arr[], if there are any
    while (j < n2) {
        arr[k] = right_arr[j];
        j++;
        k++;
    }

    // Free the allocated memory for temporary arrays
    free(left_arr);
    free(right_arr);
}

// Function to perform Merge Sort on the array
void merge_sort(int arr[], int left, int right) {
    if (left < right) {
        // Same as (left+right)/2, but avoids overflow for large left and right
        int middle = left + (right - left) / 2;

        // Recursively sort the first and second halves
        merge_sort(arr, left, middle);
        merge_sort(arr, middle + 1, right);

        // Merge the sorted halves
        merge(arr, left, middle, right);
    }
}

// Function to print an array
void print_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

// Driver program to test the functions
int main() {
    int arr[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    int size = sizeof(arr) / sizeof(arr[0]);

    printf("Original Array: ");
    print_array(arr, size);

    // Perform Merge Sort
    merge_sort(arr, 0, size - 1);

    printf("Sorted Array: ");
    print_array(arr, size);

    return 0;
}
...................................................................

3. Max and min

#include <stdio.h>

// Function to find the minimum and maximum elements in an array
void find_min_max(int arr[], int left, int right, int *min, int *max) {
    if (left == right) {
        // If there is only one element in the array
        *min = arr[left];
        *max = arr[right];
    } else if (right - left == 1) {
        // If there are two elements in the array
        *min = (arr[left] < arr[right]) ? arr[left] : arr[right];
        *max = (arr[left] > arr[right]) ? arr[left] : arr[right];
    } else {
        // If there are more than two elements, divide and conquer
        int mid = (left + right) / 2;
        int left_min, left_max, right_min, right_max;

        // Recursively find min and max in the left and right halves
        find_min_max(arr, left, mid, &left_min, &left_max);
        find_min_max(arr, mid + 1, right, &right_min, &right_max);

        // Combine the results
        *min = (left_min < right_min) ? left_min : right_min;
        *max = (left_max > right_max) ? left_max : right_max;
    }
}

// Driver program to test the function
int main() {
    int arr[] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
    int size = sizeof(arr) / sizeof(arr[0]);

    int min, max;
    find_min_max(arr, 0, size - 1, &min, &max);

    printf("Array: ");
    for (int i = 0; i < size; i++) {
        printf("%d ", arr[i]);
    }

    printf("\nMinimum Element: %d\n", min);
    printf("Maximum Element: %d\n", max);

    return 0;
}
................................................................

4. Bellmans ford algo

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

#define MAX_VERTICES 100
#define MAX_EDGES 100

// Structure to represent an edge in the graph
struct Edge {
    int source, destination, weight;
};

// Structure to represent a graph
struct Graph {
    int V, E; // Number of vertices and edges
    struct Edge edge[MAX_EDGES]; // Array to store edges
};

// Function to initialize a graph with given vertices and edges
void initializeGraph(struct Graph *graph, int vertices, int edges) {
    graph->V = vertices;
    graph->E = edges;
}

// Function to relax an edge (update the distance if a shorter path is found)
void relax(int dist[], int source, int destination, int weight) {
    if (dist[source] != INT_MAX && dist[source] + weight < dist[destination]) {
        dist[destination] = dist[source] + weight;
    }
}

// Function to perform Bellman-Ford algorithm
void bellmanFord(struct Graph *graph, int source) {
    int V = graph->V;
    int E = graph->E;
    int dist[MAX_VERTICES];

    // Initialize distances from source to all other vertices as infinity
    for (int i = 0; i < V; i++) {
        dist[i] = INT_MAX;
    }
    dist[source] = 0; // Distance from source to itself is 0

    // Relax all edges |V| - 1 times
    for (int i = 1; i <= V - 1; i++) {
        for (int j = 0; j < E; j++) {
            relax(dist, graph->edge[j].source, graph->edge[j].destination, graph->edge[j].weight);
        }
    }

    // Check for negative weight cycles
    for (int i = 0; i < E; i++) {
        int u = graph->edge[i].source;
        int v = graph->edge[i].destination;
        int weight = graph->edge[i].weight;
        if (dist[u] != INT_MAX && dist[u] + weight < dist[v]) {
            printf("Graph contains negative weight cycle. Bellman-Ford cannot solve it.\n");
            return;
        }
    }

    // Print the distances
    printf("Vertex   Distance from Source\n");
    for (int i = 0; i < V; i++) {
        printf("%d \t\t %d\n", i, dist[i]);
    }
}

// Driver program to test the functions
int main() {
    struct Graph graph;
    int vertices, edges, source;

    // Input: Number of vertices, edges, and the source vertex
    printf("Enter the number of vertices: ");
    scanf("%d", &vertices);

    printf("Enter the number of edges: ");
    scanf("%d", &edges);

    initializeGraph(&graph, vertices, edges);

    // Input the edges (source, destination, weight)
    for (int i = 0; i < edges; i++) {
        printf("Enter edge %d (source destination weight): ", i + 1);
        scanf("%d %d %d", &graph.edge[i].source, &graph.edge[i].destination, &graph.edge[i].weight);
    }

    printf("Enter the source vertex: ");
    scanf("%d", &source);

    // Perform Bellman-Ford algorithm
    bellmanFord(&graph, source);

    return 0;
}

input: 

Enter the number of vertices: 5
Enter the number of edges: 8
Enter edge 1 (source destination weight): 0 1 6
Enter edge 2 (source destination weight): 0 2 7
Enter edge 3 (source destination weight): 1 2 8
Enter edge 4 (source destination weight): 1 3 5
Enter edge 5 (source destination weight): 1 4 -4
Enter edge 6 (source destination weight): 2 3 -3
Enter edge 7 (source destination weight): 2 4 9
Enter edge 8 (source destination weight): 3 0 2
Enter the source vertex: 0

output: 

Vertex   Distance from Source
0            0
1            2
2            7
3            4
4            -4
........................................................................

5.Travelling sellsman

#include <stdio.h>
#include <limits.h>

#define MAX_CITIES 10

int min(int a, int b) {
    return (a < b) ? a : b;
}

int tsp(int graph[MAX_CITIES][MAX_CITIES], int mask, int current, int n, int dp[MAX_CITIES][1 << MAX_CITIES]) {
    // If all cities have been visited, return the cost to return to the starting city
    if (mask == (1 << n) - 1) {
        return graph[current][0];
    }

    // If the result is already calculated, return it
    if (dp[current][mask] != -1) {
        return dp[current][mask];
    }

    int minCost = INT_MAX;

    // Try visiting unvisited cities
    for (int city = 0; city < n; city++) {
        if (!(mask & (1 << city))) { // If the city is not visited
            int newMask = mask | (1 << city);
            int cost = graph[current][city] + tsp(graph, newMask, city, n, dp);

            // Update the minimum cost
            minCost = min(minCost, cost);
        }
    }

    // Save the result in the DP table
    dp[current][mask] = minCost;
    return minCost;
}

void printPath(int graph[MAX_CITIES][MAX_CITIES], int dp[MAX_CITIES][1 << MAX_CITIES], int n) {
    int path[MAX_CITIES];
    int current = 0;
    int mask = 1; // Start from the first city

    // Find the optimal path
    for (int step = 1; step < n; step++) {
        int nextCity = -1;
        for (int city = 0; city < n; city++) {
            if (!(mask & (1 << city))) { // If the city is not visited
                int cost = graph[current][city] + dp[city][mask | (1 << city)];
                if (nextCity == -1 || cost < graph[current][nextCity] + dp[nextCity][mask | (1 << nextCity)]) {
                    nextCity = city;
                }
            }
        }
        path[step] = nextCity;
        mask |= (1 << nextCity);
        current = nextCity;
    }

    // Print the optimal path
    printf("Optimal Path: 0 ");
    for (int i = 1; i < n; i++) {
        printf("%d ", path[i]);
    }
    printf("0\n");
}

int main() {
    int n;
    int graph[MAX_CITIES][MAX_CITIES];
    int dp[MAX_CITIES][1 << MAX_CITIES];

    // Input: Number of cities
    printf("Enter the number of cities: ");
    scanf("%d", &n);

    // Input: Cost matrix for traveling between cities
    printf("Enter the cost matrix for traveling between cities:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf("%d", &graph[i][j]);
        }
    }

    // Initialize the DP table
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < (1 << n); j++) {
            dp[i][j] = -1;
        }
    }

    // Find the optimal cost using dynamic programming
    int optimalCost = tsp(graph, 1, 0, n, dp);

    // Print the optimal path and cost
    printf("Optimal Cost: %d\n", optimalCost);
    printPath(graph, dp, n);

    return 0;
}
 
input :

Enter the number of cities: 4
Enter the cost matrix for traveling between cities:
0 10 15 20
5 0 9 10
6 13 0 12
8 8 9 0

output : 

Optimal Cost: 35
Optimal Path: 0 1 3 2 0
